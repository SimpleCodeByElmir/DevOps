## Part 1
1. установить Ubuntu 20.04 LTS без грфического интерфейса.
* Командой `cat /etc/issue` узнать версию убунты
![1checkVers.png](1 checkVers.png)
___
## Part 2
1. Создать пользователя, отличного от пользователя, который создавался при установке. Пользователь должен иметь разрешение на прочтение логов из папки /var/log.

* Добавить нового пользователя `sudo adduser alex`
![2usern.png](2usern.png)
* Предоставить пользователю права на чтение логов `sudo chown -R alex: /var/log
![2Alexgetpermis.png](2Alexgetpermis.png)
* Новый пользователь должен быть в выводе команды `cat /etc/passwd`
![2cat.png](2cat.png)
___
## Part 3
1. Задать им машины вида user-1
  команда: `sudo hostnamectl set-hostname имя` и заменить его на user-1.
  ![3hostnamectl set.png](3hostnamectl set.png)
2. Поменять дату и время в зависимости от территориального расположения машины. Команда: 
* `timedatectl` - показывает информацию о дате, времени и часовом поясе. 
* `sudo timedatectl set-timezone Europe/Moscow`
  ![3timezone.png](3timezone.png)

3. Вывести названия сетевых интерфейсов с помощью консольной команды. И дать обьяснение  интерфейсу lo.
* lo - это аппаратный или программный метод, который направляет полученный сигнал или данные обратно отправителю. Он используется как дополнительное средство в исправлении проблем физического соединения.
Команда для вывода сетевых интерфейсов:
`ip link show`
![3ip link show.png](3ip link show.png)

4. Иcпользуя консольную команду получить ip адресс устройства. На котором я работаю от DHCP сервера. И дать расшифровку DHCP.
* `DCHP` — протокол динамической настройки узла) — прикладной протокол, позволяющий сетевым устройствам автоматически получать IP-адрес и другие параметры, необходимые для работы в сети TCP/IP. Данный протокол работает по модели «клиент-сервер». Для автоматической конфигурации компьютер-клиент на этапе конфигурации сетевого устройства обращается к так называемому серверу DHCP и получает от него нужные параметры. Сетевой администратор может задать диапазон адресов, распределяемых сервером среди компьютеров. Это позволяет избежать ручной настройки компьютеров сети и уменьшает количество ошибок. Протокол DHCP используется в большинстве сетей TCP/IP.
* `ip a` или `ip add` или `hostname -I` - показать внутренний ip адрес устройства (у меня это 10.0.2.15/24)
* `curl icanhazip.com` - узнать внешний ip адрес устройства (у меня это 178.207.154.253)
* `ip route` - показать ip адрес шлюза (gateway - он же внутренний ip)
![3ip a.png](3ip a.png)

6. Задать статичные (заданные вручную, а не полученные от DHCP сервера) настройки ip, gw, dns (использовать публичный DNS серверы, например 1.1.1.1 или 8.8.8.8).Команды: 
* Выше мы унали адрес шлюза командой ` ip route`.
* Ввести команду `sudo vim /etc/netplan/00-installer-config.yaml` и внести изменения
![3static ip.png](3static ip.png)
* после сохраняем изменения командой `sudo netplan apply`
* перезагружаем машину командой `sudo reboot` и проверяем ip машины.
![3check new ip.png](3check new ip.png)

7.
* Успешно пропинговать командой `ping 1.1.1.1` и `ping ya.ru`
![3ping.png](3ping.png)
___
## Part 4
1. Обновить пакеты убунту
* `sudo apt-get update` Обновляет индекс пакетов системы
* `sudo apt-get upgrade` Обновляет все устаревшие пакеты до последних версий
![4update upgrade.png](4update upgrade.png)
* После обновления системных пакетов, если ввести команду обновления повторно, должно появится сообщение, что обновления отсутствуют
![4check.png](4check.png)
___
## Part 5
1. Обьяснить истинное назначение команды sudo
* Команда sudo предоставляет возможность пользователям выполнять команды от имени суперпользователя root, либо других пользователей. Правила, используемые sudo для принятия решения о предоставлении доступа, находятся в файле `/etc/sudoers` (для редактирования файла можно использовать специальный редактор visudo, запускаемый из командной строки без параметров, в том числе без указания пути к файлу); язык их написания и примеры использования подробно изложены в man sudoers).Имя команды означает substitute user do или super user do. Утилита позволяет запускать программы от имени другого пользователя, но чаще всего от имени корневого. Утилита была разработана еще в 1980 году Бобом Когшелом и Клиффом Спенсером. За это время сменилось много разработчиков и было добавлено много функций.
2. Поменять hostname ОС от имени пользователя, созданного в пункте Part 2. (используя sudo).
* Добавляем пользователя alex в группу sudo:  `sudo usermod -aG sudo alex`
![5makealsudo.png](5makealsudo.png)
* Проверяем все ли получилось: `id alex`, также залогинимся на "alex" `su alex` и запустим команду  `sudo -l`, далее изменим имя машины на "user-3":
`sudo hostnamectl set-hostname user-3`
![5hostname.png](5hostname.png)

___
## Part 6 Установка и настройка службы времени
1. **Настроить службу автоматической синхронизации времени.**

Синхронизация времени по NTP.
* NTP - это протокол синхронизации времени по сети. По существу клиенты запрашивают текущее время на сервере и используют его для установки своих собственных часов.
**Ubuntu использует ntpdate и ntp.**

* **ntp**
* Сервис NTP вычисляет отставание наших системных часов и постоянно подправляет их, благодаря чему не происходит существенных изменений, которые могут приводить к "беспорядку" в журналах. Ценой этому небольшое расходование мощности процессора и оперативной памяти, но для современного сервера это незначительно.
**Установка**
Для установки NTP из терминала вводим: `sudo apt-get install ntp`
![6ntp.png](6ntp.png)

2.**Вывести время, часового пояса, в котором вы сейчас находитесь.**
* Время и дату можно узнать командой: `date`
**Вывод следующей команды должен содержать NTPSynchronized=yes: **
`timedatectl show`
![6timedatectl show.png](6timedatectl show.png)

___
## Part 7
1.Установить текстовые редакторы VIM (+ любые два по желанию NANO, MCEDIT, JOE и т.д.)
* Команда для установки ПО: `sudo apt install vim` (или nano или joe)
![7apt.png](7apt.png)

2. Используя каждый из трех выбранных редакторов, создайте файл test_X.txt, где X -- название редактора, в котором создан файл. Напишите в нём свой никнейм, закройте файл с сохранением изменений.

* Открываем текстовый редактор vim - введём команду: `vim filename`
![7vim2.png](7vim2.png)
для выхода с редактора нажимаем `shift+:`. Затем пишем `wq` и нажимаем `enter`
* Открываем текстовый редактор nano - введём команду: `nano filename`
![7nano1.png](7nano1.png)
для выхода нажимаем `control + X`. Затем выбираем пункт `Yes` и жмём `enter`
* Открываем текстовый редактор JOE - введём команду: `joe filename`
![7joe.png](7joe.png)
Для выхода жмём на клавиши `ctrl+K+Х` для сохранения и выхода в консоль терминала.

3. Используя каждый из трех выбранных редакторов, откройте файл на редактирование, отредактируйте файл, заменив никнейм на строку "21 School 21", закройте файл без сохранения изменений.

* В Vim жмём Escape и вводим ":q!" и "enter" - для выхода в консоль терминала без сохранения внесённых изменений.
![7vim q!.png](7vim q!.png)
* В Nano нажимаем ctrl+X для выхода без сохранения, на вопрос редактора "Save modified buffer?", выбираем N -> No, выходим в консоль терминала.`ctrl + X` затем `N
![7nano No.png](7nano No.png)
* В Joe нажимаем ctrl+C для выхода без сохранения, на вопрос редактора "Lose changes to this file (y,n,^C)?", выбираем Y -> Yes, выходим в консоль терминала.
![7joe ctrl+C.png](7joe ctrl+C.png)

* **Проверим не сохранился ли новый текст**
![7check.png](7check.png)

3. Используя каждый из трех выбранных редакторов, отредактируйте файл ещё раз (по аналогии с предыдущим пунктом), а затем освойте функции поиска по содержимому файла (слово) и замены слова на любое другое.

* **VIM**
* В Vim мы можем найти и заменить текст с помощью команды `:substitute(:s)`.
если добавить "%", то поиск и замена будут осуществленны на всех строчках в файле.
`:%s/Linux/Unix`.
![7vimlinux.png](7vimlinux.png)
![7vimunix.png](7vimunix.png)

* **nano**
* Чтобы в редакторе nano выполнить поиск и замену текста используем сочетание клавиш:
`Ctrl+\`
Нажимаем `Ctrl+`, вводим строку, которую необходимо искать и нажимаем клавишу Enter. Затем вводим строку, на которую необходимо произвести замену и нажимаем `Enter`.
После этого появится предложение по замене первого вхождения нашей строки. Мы можем нажать:
`A` — Выполнить автоматическую замену всех вхождений строки;
`Y` — Выполнить замену данной найденной строки (после этого мы переместимся к следующему в хождению искомой строки);
`N` — Отменить замену данной строки (после этого мы переместимся к следующему вхождению искомой строки);
`Ctrl+C `— Прервать поиск.
`Ctrl+`
Search (to replace):
Replace (with):
Replace this instance?
`Y` Yes `A` All
`N` No `^C` Cancel
![7nanolinux.png](7nanolinux.png)
![7nanounix.png](7nanounix.png)
![7nanodone.png](7nanodone.png)

* **Joe**
* Нажимаем `ctrl+K+F`, чтобы выполнить поиск фрагмента текста (строки) вперед или назад. У нас будет запрошен образец поиска. После нажатия Enter мы получим запрос на ввод опций поиска. Мы можем просто нажать Enter еще раз, чтобы редактор сразу начал поиск вперед, или можем ввести одну или больше из следующих опций:
`b` - Поиск назад, а не вперед;
`i` - Не различать при поиске символы верхнего и нижнего регистров. Обычно считается, что они различны;
nnn (где nnn - число) - Если мы введем число - JOE найдет n-ное вхождение искомого текста. Это полезно для перехода в нужные места внутри файлов, структурированных некоторым определенным образом;
`r` - Замещать текст.
Если мы введем опцию r, далее у нас будет запрошен замещающий текст. Каждый раз при нахождении текста у нас будет запрашиваться - желаем ли мы выполнить его замещение. Мы можем нажать:
`y` - для замещения текста и выполнения дальнейшего поиска;
`n` - чтобы не замещать текст, но продолжать поиск;
`r` - для замены всех последующих вхождений далее по файлу без дополнительных запросов на подтверждение, или ^C для прекращения поиска и замены.
Мы можем нажать `^L` для повторения предыдущего поиска.
![7joe1.png](7joe1.png)
![7joe2.png](7joe2.png)
![7joe3.png](7joe3.png)
![7joe4.png](7joe4.png)
![7joe5.png](7joe5.png)
![7joe6.png](7joe6.png)
![7allcheck.png](7allcheck.png)
____
## Part 8 Установка и базовая настройка
1. **Установка службы SSHd** 
* Установить SSH-сервер в системе:
`sudo apt-get install openssh-server`
* После установки пакета сервера SSH демон сервера SSH должен быть запущен. Чтобы проверить состояние вашего SSH-сервера, выполните следующую команду:
`sudo systemctl status sshd`
![8install.png](8install.png)
![8status.png](8status.png)
2. **Добавить автостарт службы при загрузке системы**
* Для включения автостарта службы воспользуемся командой:
`sudo systemctl enable ssh`
![8enable sshd.png](8enable sshd.png)
3. **Перенастроить службу SSHd на порт 2022.**
*Отредактировать файл конфигурации с помощью команды:
`vim /etc/ssh/sshd_config`
Откроем файл и найдём строку, определяющую порт: Port 22
Поменяем его на 2022.
![8port2022.png](8port2022.png)
Затем перезапустим службу `sudo systemctl restart sshd`.
![8restart.png](8restart.png)
4. **Используя команду ps, показать наличие процесса sshd. Для этого к команде нужно подобрать ключи.**
* Утилита ps одна из самых простых и в то же время часто используемых программ для просмотра списка процессов в Linux. Она не поддерживает интерактивный режим, зато имеет множество опций для настройки вывода тех или иных параметров процессов в Linux.
Процесс Linux - это экземпляр программы, запущенный в памяти. Все процессы можно разделить на обычные и фоновые.
Linux - это многопользовательская система, каждый пользователь может запускать одни и те же программы, и даже один пользователь может захотеть запустить несколько экземпляров одной программы, поэтому ядру нужно как-то идентифицировать такие однотипные процессы. Для этого каждому процессу присваивается PID (Proccess Identificator).
Каждый из процессов может находиться в одном из таких состояний:
Запуск - процесс либо уже работает, либо готов к работе и ждет, когда ему будет дано процессорное время;
Ожидание - процессы в этом состоянии ожидают какого-либо события или освобождения системного ресурса. Ядро делит такие процессы на два типа - те, которые ожидают освобождения аппаратных средств и приостановление с помощью сигнала;
Остановлено - обычно, в этом состоянии находятся процессы, которые были остановлены с помощью сигнала;
Зомби - это мертвые процессы, они были остановлены и больше не выполняются, но для них есть запись в таблице процессов, возможно, из-за того, что у процесса остались дочерние процессы.
Рассмотрим общий синтаксис команды, здесь все очень просто:
`ps опции`
`ps опции | grep параметр`
Во втором варианте мы используем утилиту grep для того, чтобы отобрать нужные нам процессы по определенному критерию.
**Теперь рассмотрим опции утилиты:**
`A, -e` - выбрать все процессы;
`-a` - выбрать все процессы, кроме фоновых;
`-d` - выбрать все процессы, даже фоновые, кроме процессов сессий;
`-N` - выбрать все процессы кроме указанных;
`-С` - выбирать процессы по имени команды;
`-G` - выбрать процессы по ID группы;
`-p` - выбрать процессы PID;
`--ppid` - выбрать процессы по PID родительского процесса;
`-s` - выбрать процессы по ID сессии;
`-t` - выбрать процессы по tty;
`-u` - выбрать процессы пользователя;
`-x` - найти все вхождения строки поиска.
Опции форматирования:
`-с` - отображать информацию планировщика;
`-f` - вывести максимум доступных данных, например, количество потоков;
`-F` - аналогично `-f`, только выводит ещё больше данных;
`-l` - длинный формат вывода;
`-j` - вывести процессы в стиле Jobs, минимум информации;
`-M` - добавить информацию о безопасности;
`-o` - позволяет определить свой формат вывода;
`--sort` - выполнять сортировку по указанной колонке;
`-L` - отображать потоки процессов в колонках LWP и NLWP;
`-m` - вывести потоки после процесса;
`-V` - вывести информацию о версии;
`-H` - отображать дерево процессов.
* Мы будем использовать следующую команду:
`ps -aux | grep ssh`
![8ps-aux.png](8ps-aux.png)
5. **Перезапустить систему**
`sudo reboot`
* **Вывод команды netstat -tan должен содержать tcp 0 0 0.0.0.0:2022 0.0.0.0:* LISTEN (если команды netstat нет, то ее нужно установить).**
* Устанавливаем netstat с помощью команды:
`sudo apt-get install net-tools`
* `netstat` (network statistics) — утилита командной строки, выводящая на дисплей состояние TCP-соединений (как входящих, так и исходящих), таблицы маршрутизации, число сетевых интерфейсов и сетевую статистику по протоколам.
![8apt netstat.png](8apt netstat.png)
![8netstat-tan.png](8netstat-tan.png)
* `-t` - Отображение текущего подключения в состоянии переноса нагрузки с процессора на сетевой адаптер при передаче данных.
`-a` - Отображение всех подключений и ожидающих портов.
`-n` - Отображение адресов и номеров портов в числовом формате.
**TCP/IP** — сетевая модель передачи данных, представленных в цифровом виде. Модель описывает способ передачи данных от источника информации к получателю.
proto - название порта.
Local address - локальный адрес.
Foreign address - внешний адрес, учавствующий в создании соединения.
State - состояние соединения, все варианты.
CLOSE_WAIT - ожидание закрытия соединения.
CLOSED - соединение закрыто.
ESTABLISHED - соединение установлено.
LISTENING - ожидается соединение (слушается порт).
TIME_WAIT - превышение времени ответа.
**Адрес** 0.0.0.0 означает «любой IP данного компьютера» и включает в себя в том числе 127.0.0.1. Адрес 0.0.0.0 обычно означает, что IP адрес ещё не настроен или не присвоен. Такой адрес указывает хост, который обращается к DHCP для получения IP адреса.

## Part 9
1. **ОПЦИИ И КОМАНДЫ TOP.**
Опций запуска у команды не много и использовать их активно не принято, потому что большинство действий выполняются с помощью интерактивных команд. Вот основные опции:
-v - вывести версию программы;
-b - режим только для вывода данных, программа не воспринимает интерактивных команд и выполняется пока не будет завершена вручную;
-c - отображать полный путь к исполняемым файлам команд;
-d - интервал обновления информации;
-H - включает вывод потоков процессов;
-i - не отображать процессы, которые не используют ресурсы процессора;
-n - количество циклов обновления данных, после которых надо закрыть программу;
-o - поле, по которому надо выполнять сортировку;
-O - вывести все доступные поля для сортировки;
-p - отслеживать только указанные по PID процессы, можно указать несколько PID;
-u - выводить только процессы, запущенные от имени указанного пользователя.
С опциями запуска всё, теперь давайте поговорим про интерактивные команды, которые вы можете выполнять во время работы программы.
h - вывод справки по утилите;
q или Esc - выход из top;
A - выбор цветовой схемы;
d или s - изменить интервал обновления информации;
H - выводить потоки процессов;
k - послать сигнал завершения процессу;
W - записать текущие настройки программы в конфигурационный файл;
Y - посмотреть дополнительные сведения о процессе, открытые файлы, порты, логи и т д;
Z - изменить цветовую схему;
l - скрыть или вывести информацию о средней нагрузке на систему;
m - выключить или переключить режим отображения информации о памяти;
x - выделять жирным колонку, по которой выполняется сортировка;
y - выделять жирным процессы, которые выполняются в данный момент;
z - переключение между цветным и одноцветным режимами;
c - переключение режима вывода команды, доступен полный путь и только команда;
F - настройка полей с информацией о процессах;
o - фильтрация процессов по произвольному условию;
u - фильтрация процессов по имени пользователя;
V - отображение процессов в виде дерева;
i - переключение режима отображения процессов, которые сейчас не используют ресурсы процессора;
n - максимальное количество процессов, для отображения в программе;
L - поиск по слову;
<> - перемещение поля сортировки вправо и влево.
* **УПРАВЛЕНИЕ.**
Для работы с утилитой top используются следующие клавиши:
Пробел — обновить вывод
M — сортировка по используемой памяти
P — сортировка по нагрузке на процессор (используется по умолчанию)
T — сортировка по времени работы процесса
A — сортировка по максимальному потреблению различных ресурсов
u — сортировка по имени пользователя (потребуется ввести имя пользователя)
k — завершить процесс (потребуется указать его идентификатор, PID)
n — изменить количество процессов в выводе (потребуется указать нужное количество)
c — вывести полный путь запущенного процесса (столбец COMMAND)
h — вывод справки
q — выход из программы
* **ЗАПУСК ПРОГРАММЫ.**
* Утилита не всегда установлена по умолчанию, для её установки в Ubuntu используйте команду:
`sudo apt install top`
![9apttophtop.png](9apttophtop.png)
Затем для запуска просто выполните в терминале:
`top`
![9top.png](9top.png)
Окно можно условно разделить на две части. В верхней части находится информация о системе, общем использовании ресурсов процессора и памяти, раздела подкачки, и так далее. В нижней части окна расположен список запущенных процессов с информацией, отсортированных по определённому полю.
Если все процессы не помещаются на одном экране, их можно листать с помощью стрелок вверх и вниз. Если не помещаются все колонки - с помощью стрелок вправо и влево.
Слева вверху указано текущее время системы, далее:
Up — время работы системы с последнего запуска. -> 1 min
User — количество текущих пользователей. -> 1 user
Load average — средняя нагрузка на сервер: отображаются значения за одну, пять и 15 минут назад. ->0.28 0.13, 0.05
Tasks — общее количество запущенных процессов в разных статусах (running — выполняемые; sleeping — в ожидании; stopped — остановленные; zombie — «зомби», дочерние процессы, ожидающие завершения родительского процесса). -> 102 total, 1 running, 101 sleeping, 0 stopped, 0 zombie
Cpu(s) — процент времени процессора, затраченного на выполнение процессов, в том числе:
us — пользовательские процессы (высокое значение данного показателя может указывать, в том числе, на проблемы в коде сайта, необходимость его оптимизации); -> 0.0
sy — процессы ядра; -> 0.0
id — неиспользуемые ресурсы (чем выше этот показатель, тем лучше); -> 98.7
wa — операции ввода/вывода, т.е. дисковые операции. -> 1.3
Mem, Swap — сведения об использовании оперативной памяти (total — общий объем, free — объем свободной памяти, used — объем использованной памяти). -> Mem total 1983.4, Mem free 1146.7, Mem used 147.6, Swap total 2048, Swap free 2048, Swap used 0.0
Команда `uptime` - показывает общую продолжительность работы системы с момента последней загрузки (временной отрезок).
![9uptime command.png](9uptime command.png)
**Команда w** — отображает информацию о пользователях которые в настоящее время есть на машине, и их процессов. Внутри заголовка, показывается текущее время, как долго система работает, сколько пользователей в настоящее время вошли в систему, и среднюю нагрузку системы за последние 1, 5 и 15 минут.
* `w`
![9w command.png](9w command.png)
Надо сказать, что аналогично утилите top, можно использовать htop, что намного проще. Пользовательский интерфейс программы htop основан на Ncurses. Представление информации действительно чистое. С помощью этого инструмента вы можете фильтровать, управлять и делать другие интересные вещи, связанные с процессами, запущенными в вашей системе. Это отличный инструмент для системных администраторов Gnu / Linux.
* `htop`
![9htopf6.png](9htopf6.png)
Обозначения столбцов:
PID — идентификатор процесса;
USER — пользователь, запустивший процесс;
PR — приоритет процесса;
NI — измененный приоритет (присвоенный пользователем с помощью команды nice);
VIRT — объем используемой виртуальной памяти (здесь выводится тот объем памяти, который был запрошен процессом, даже если фактически используется меньше);
RES — объем используемой оперативной памяти
SHR — объем памяти, разделяемой с другими процессами (т.е. память, которая может быть использована другими процессами);
S — статус процесса (running — запущен; sleeping — в ожидании; zombie — процесс-«зомби»):top
D = бесперебойный сон;
I = простой (не работает);
R = запущен;
S = спит;
T = остановлен сигналом управления работой;
t = остановлен отладчиком во время трассировки;
Z = зомби.
%CPU — процент использования процессорного времени;
%MEM — процент использования оперативной памяти;
TIME — общее время работы процесса;
COMMAND — имя процесса (команда, которой был запущен процесс).
**Для управления сортировкой можно использовать клавиши M (сортировка по памяти), P (по процессору), T (по времени), аналогично утилите top. Так же можно воспользоваться клавишей F6 -> SortBy.**
При нажатии клавиши F6 экран сменится и будет предоставлен выбор вариантов сортировки. Выбираем необходимый вариант с помощью стрелок ввер, вниз и нажимаем enter.
Отсортируем по PID.
![9htop sort by pid.png](9htop sort by pid.png)
Отсортируем по Percent_CPU
![9percent_cpu.png](9percent_cpu.png)
Отсортируем по PERCENT_MEM.
![9htop percent_mem.png](9htop percent_mem.png)
Отсортируем по TIME.
![9htop time.png](9htop time.png)
Теперь для данных выводов PID, PERCENT_CPU, PEERCENT_MEM, TIME **выполним фильтрации по процессу sshd. Воспользуемся клавишей F4 -> Filter.**
![9_3.1.png](9_3.1.png)
![9_3.2.png](9_3.2.png)
![9_3.3.png](9_3.3.png)
![9_3.4.png](9_3.4.png)
**Выполним поиск процесса syslog. Отключаем все предыдущие настройки фильтрации, далее, воспользуемся клавишей F3 -> Search.**
![9F3 syslog searching.png](9F3 syslog searching.png)
**Используя клавишу F2 -> Setup, выполняем добавление пунктов hostname, clock и uptime в панель вывода.**
![9adding1.png](9adding1.png)
![9adding2.png](9adding2.png)
![9check.png](9check.png)
Настройку требуемых для дополнительного вывода параметров осуществляем с помощью команд консольного меню расположенного в нижней части экрана.
## Part 10
1. **Использование утилиты fdisk**
ОПЦИИ И СИНТАКСИС FDISK
* Синтаксис утилиты ничем не отличается от других команд Linux:
`fdisk`
* Ей надо передать опции, согласно действия, которое вы хотите выполнить, а также раздел диска или устройство к которому эти действия надо применить. Давайте теперь рассмотрим опции fdisk:
`-B`, `--protect-boot` - не стирать первые 512 байт диска чтобы не повредить загрузочную запись;
`-L`, `--color` - настройка цветного вывода, возможные значения auto, never или always;
`-l`, `--list` - вывести все разделы на выбранных устройствах или если устройств не задано, то на всех устройствах;
`-o`, `--output` - указывает какие поля данных надо показывать в выводе программы, доступные поля рассмотрим ниже;
`-u`, `--units` - настраивает формат вывода размера разделов, доступные значения: cylinders, sectors, по умолчанию используется sectors;
`-w`, `--wipe` - режим стирания файловой системы или RAID с диска, возможные значения auto, never или always по умолчанию используется auto;
`-W`, `--wipe-partition` - режим стирания файловой системы или RAID из только что созданного раздела. Возможные значения аналогичны предыдущей опции;
`-h`, `--help` - показать справку по утилите;
`-v`, `--version` - опция выводит версию утилиты.
Опции используются для настройки работы утилиты, мы рассмотрели только самые главные, которые могут вам пригодится, теперь перейдём к командам:
`a` - включение или выключения флага boot для раздела;
`d` - удалить раздел;
`F` - показать свободное место;
`l` - вывести список известных типов разделов;
`n` - создать новый раздел;
`p` - вывести таблицу разделов;
`t` - изменение типа раздела;
`i` - вывести информацию о разделе;
`I` и O - записать или загрузить разметку в файл сценария sfdisk;
`w` - записать новую таблицу разделов на диск;
`q` - выйти без сохранения;
`g` - создать пустую таблицу разделов GPT;
`o` - создать пустую таблицу разделов MBR.
* Воспользуемся следующей командой:
`sudo fdisk -l`
![10fdisk -l.png](10fdisk -l.png)
Название жёсткого диска: sda
Размер жёсткого диска: 10 GiB.
Количество секторов: 20971520 sectors.
При создании виртуальной машины swap не создавался.
* Проанализируем наличие пространства под SWAP:
`sudo fdisk -h`
Видим, что размер SWAP равен 1.7Gi
![10free -h.png](10free -h.png)
## Part 11.
1.  **КОМАНДА DF LINUX.**
* Утилита df поставляется по умолчанию во всех дистрибутивах Linux и имеет очень простой синтаксис. Фактически вы можете просто набрать df и уже получить результат, но чтобы сделать вывод более читаемым используются дополнительные опции. Вот основной синтаксис:
* `df опции устройство`
* Устройство указывать необязательно, но можно указать раздел диска, о котором мы хотим посмотреть информацию. А теперь рассмотрим основные опции утилиты:
`-a`, `--all` - отобразить все файловые системы, в том числе виртуальные, псевдо и недоступные;
`-B` - изменить размер одного блока перед выводом данных, например, можно использовать BM, чтобы вывести все данные в мегабайтах;
`-h` - выводить размеры в читаемом виде, в мегабайтах или гигабайтах;
`-H` - выводить все размеры в гигабайтах;
`-i` - выводить информацию об inode;
`-k` - выводить размеры в килобайтах;
`--output` - использовать специальный формат вывода, если не задано, выводит все поля. Доступны такие варианты: 'source', 'fstype', 'itotal', 'iused', 'iavail', 'ipcent', 'size', 'used', 'avail', 'pcent', 'file' и 'target';
`-P` - использовать формат вывода POSIX;
--total - выводить всю информацию про использованное и доступное место;
`-t`, --type - выводить информацию только про указанные файловые системы;
`-x` - выводить информацию обо всех, кроме указанных файловых систем.
Утилита отображает стандартный набор колонок, но понять в ее выводе что-то с первого раза сложно. Все данные выводятся в килобайтах.
* Вызовем программу:
`sudo df`
![11sudodf.png](11sudodf.png)
Размер корневого раздела: 9336140. (Данные выводятся в килобайтах)
Размер занятого пространства: 4968864. (Данные выводятся в килобайтах)
Размер свободного пространства: 3873300. (Данные выводятся в килобайтах)
Процент использования: 57%.
Мы видим, что используется файловая система ext4.
Ext4 — журналируемая файловая система, предлагаемая для использования по умолчанию инсталятором Ubuntu, начиная с версии 9.10.
* Далее, согласно задания применим команду:
`sudo df -Th`
![11sudo-Th.png](11sudo-Th.png)
Размер корневого раздела: 9.0G (Данные выводятся в гигабайтах)
Размер занятого пространства: 4.8G (Данные выводятся в гигабайтах)
Размер свободного пространства: 3.7G (Данные выводятся в гигабайтах)
Процент использования: 57%.
Мы видим, что используется файловая система ext4.
Ext4 — журналируемая файловая система, предлагаемая для использования по умолчанию инсталятором Ubuntu, начиная с версии 9.10.

## Part 12. Использование утилиты du
* **Синтаксис и опций команды DU**
Синтаксис команды очень простой. Вам достаточно передать ей опций и путь к папке с которой следует работать:
`du опции /путь/к/папке`
* А вот опции утилиты:
`-a`, `--all` - выводить размер для всех файлов, а не только для директорий, по умолчанию размер выводится только для папок;
`-B`, `--block-size` - указать единицы вывода размера, доступно: K,M,G,T,P,E,Z,Y для 1024 и KB, MB и так далее для 1000;
`-c`, `--total` - выводить в конце общий размер всех папок;
`-d`, `--max-depth` - максимальная глубина вложенности директорий;
`-h`, `--human-readable` - выводить размер в единицах измерения удобных для человека;
`--inodes` - выводить информацию об использованию inode;
`-L`, `--dereference` - следовать по всем символическим ссылкам;
`-l`, `--count-links` - учитывать размер файла несколько раз для жестких ссылок;
`-P`, `--no-dereference` - не следовать по символическим ссылкам, это поведение используется по умолчанию;
`-S`, `--separate-dirs` - не включать размер подпапок в размер папки;
`--si` - выводить размер файлов и папок в системе си, используется 1000 вместо 1024;
`-s`, `--summarize` - выводить только общий размер;
`-t`, `--threshold` - не учитывать файлы и папки с размером меньше указанного;
`--time` - отображать время последней модификации для файла или папки, вместо времени модификации можно выводить такие метки: atime, access, use, ctime;
`-X`, `--exclude` - исключить файлы из подсчёта;
`-x`, `--one-file-system` - пропускать примонтированные файловые системы;
`--version` - вывести версию утилиты.
1. **Запустить команду du:**
`sudo du`
![12du.png](12du.png)
![12duend.png](12duend.png)
2. **Вывести размер папок /home, /var, /var/log (в байтах, в человекочитаемом виде):**
* `sudo du -h -d 0 /home /var`
* `sudo du -h -d 0 /var/log`
* 172K /home
* 809M /var
* 77M /var/log
![12sizes.png](12sizes.png)
3. **Вывести размер всего содержимого в /var/log (не общее, а каждого вложенного элемента, используя):**
* `sudo du -h -d 0 /var/log/*`
![12sizeoflogs.png](12sizeoflogs.png)
## Part 13. Установка и использование утилиты ncdu.
Ncdu (NCurses Disk Usage) является инструментом командной строки для просмотра и анализа использования дискового пространства на Linux. Он может показать древовидные каталоги и дать отчет о свободном пространстве на нашем диске, используемого в отдельных каталогах. Таким образом, очень легко отследить сколько занимает места файлы / каталоги. Он на самом деле позволяет пользователю сделать это гораздо быстрее, чем менеджеры с графическим интерфейсом.
1. **Установить утилиту ncdu.**
ncdu доступен по умолчанию в Ubuntu, Linux Mint и в репозитории Debian.
* Чтобы установить выполним команду:
`sudo apt-get install nсdu`
![13install ncdu.png](13install ncdu.png)
2. **Вывести размер папок /home, /var, /var/log.**
* `sudo ncdu /home`
![13ncduhome.png](13ncduhome.png)
`sudo ncdu /var`
![13ncduvar.png](13ncduvar.png)
`sudo ncdu /var/log`
![13ncdulog.png](13ncdulog.png)
## Part 14
* **Большинство лог файлов содержится в директории /var/log.**
* /var/log/syslog или /var/log/messages содержит глобальный системный журнал, в котором пишутся сообщения с момента запуска системы, от ядра Linux, различных служб, обнаруженных устройствах, сетевых интерфейсов и много другого.
* /var/log/auth.log или /var/log/secure — информация об авторизации пользователей, включая удачные и неудачные попытки входа в систему, а также задействованные механизмы аутентификации.
* /var/log/dmesg — драйвера устройств. Одноименной командой можно просмотреть вывод содержимого файла. Размер журнала ограничен, когда файл достигнет своего предела, старые сообщения будут перезаписаны более новыми. Задав ключ --level= можно отфильтровать вывод по критерию значимости.
* /var/log/alternatives.log — Вывод программы update-alternatives, в котором находятся символические ссылки на команды или библиотеки по умолчанию.
* /var/log/anaconda.log — Записи, зарегистрированные во время установки системы.
* /var/log/audit — Записи, созданные службой аудита auditd.
* /var/log/boot.log — Информация, которая пишется при загрузке операционной системы.
* /var/log/cron — Отчет службы crond об исполняемых командах и сообщения от самих команд.
* /var/log/cups — Все, что связано с печатью и принтерами.
* /var/log/faillog — Неудачные попытки входа в систему. Очень полезно при проверке угроз в системе безопасности, хакерских атаках, попыток взлома методом перебора. Прочитать содержимое можно с помощью команды faillog.
* var/log/kern.log — Журнал содержит сообщения от ядра и предупреждения, которые могут быть полезны при устранении ошибок пользовательских модулей встроенных в ядро.
* /var/log/maillog/ или /var/log/mail.log — Журнал почтового сервера, используемого на ОС.
* /var/log/pm-powersave.log — Сообщения службы экономии заряда батареи.
* /var/log/samba/ — Логи файлового сервера Samba, который используется для доступа к общим папкам Windows и предоставления доступа пользователям Windows к общим папкам Linux.
* /var/log/spooler — Для представителей старой школы, содержит сообщения USENET. Чаще всего бывает пустым и заброшенным.
* /var/log/Xorg.0.log — Логи X сервера. Чаще всего бесполезны, но если в них есть строки начинающиеся с EE, то следует обратить на них внимание.
* **Для каждого дистрибутива будет отдельный журнал менеджера пакетов.**
* /var/log/yum.log — Для программ установленных с помощью Yum в RedHat Linux.
* /var/log/emerge.log — Для ebuild-ов установленных из Portage с помощью emerge в Gentoo Linux.
* /var/log/dpkg.log — Для программ установленных с помощью dpkg в Debian Linux и всем семействе родственных дистрибутивах.
* **И немного бинарных журналов учета пользовательских сессий.**
* /var/log/lastlog — Последняя сессия пользователей. Прочитать можно командой last.
* /var/log/tallylog — Аудит неудачных попыток входа в систему. Вывод на экран с помощью утилиты pam_tally2.
* /var/log/btmp — Еже один журнал записи неудачных попыток входа в систему. Просто так, на всякий случай, если вы еще не догадались где следует искать следы активности взломщиков.
* /var/log/utmp — Список входов пользователей в систему на данный момент.
* /var/log/wtmp — Еще один журнал записи входа пользователей в систему. Вывод на экран командой utmpdump.
1. **Написать в отчёте время последней успешной авторизации, имя пользователя и метод входа в систему.**
Откроем для просмотра, необходимые по заданию, системные журналы для чтения:
* `less var/log/dmesg`
* `less var/log/syslog`
* `less var/log/auth.log`
![14less1.png](14less1.png)
![14less2.png](14less2.png)
![14less3.png](14less3.png)
![14less4.png](14less4.png)
* Найдём в системном журнале auth.log время последней успешной авторизации, имя пользователя и метод входа в систему, запустив команду:
* `sudo grep -ai LOGIN var/log/auth.log`
![14bylogin.png](14bylogin.png)
Увидим информацию о последнем авторизации методом ввода логина и пароля:
Jun 11  14:31:15 addisona BY LOGIN
** 2. Перезапустить службу SSHd.**
Команда systemctl довольно хорошо известна среди пользователей Linux, когда речь идет о включении, отключении, остановке и запуске любой службы. Итак, мы сначала использовали команду systemctl, чтобы включить сервер ssh. Ключевым здесь является слово «enable», наряду с ключевым словом «ssh». Он включит ssh-сервер, синхронизировав скрипт sysv. Вывод этой команды показан ниже на изображении:
* `sudo systemctl restart sshd`
![14restartsshd.png](14restartsshd.png)
* Найдём информацию о рестарте sshd службы в системном журнале "auth.log":
* `sudo grep -a restart var/log/auth.log`
![14logofsshd.png](14logofsshd.png)
Рестарт был: Jun 10 23:58:17
## Part 15 **Использование планировщика заданий CRON.**
**УСТАНОВКА CRONE.**
* Почти в каждом дистрибутиве Linux cron в каком-то виде установлен по умолчанию. Но если на вашей машине демона cron нет, вы можете установить его с помощью менеджера пакетов.
* Затем установите cron с помощью этой команды:
`sudo apt-get install cron`
* Системным администраторам, да и обычным пользователям часто приходится автоматизировать различные задачи по обслуживанию и работе с Linux с помощью скриптов. Это очень удобно, вы просто запускаете скрипт, и он делает все что необходимо без вашего вмешательства. Следующий шаг в этом пути - настроить автоматически запуск нужного скрипта в нужное время.
* Именно для этих задач в Linux используется системный сервис cron. Это планировщик, который позволяет выполнять нужные вам скрипты раз в час, раз в день, неделю или месяц, а также в любое заданное вами время или через любой интервал. Программа часто используется даже другими службами операционной системы.
* Фактически, Cron - это сервис, как и большинство других сервисов Linux, он запускается при старте системы и работает в фоновом режиме. Его основная задача выполнять нужные процессы в нужное время. Существует несколько конфигурационных файлов, из которых он берет информацию о том что и когда нужно выполнять. Сервис открывает файл /etc/crontab, в котором указаны все нужные данные. Часто, в современных дистрибутивах там прописан запуск утилиты run-parts, которая запускает нужные скрипты из следующих папок:
* /etc/cron.minutely - каждую минуту;
* /etc/cron.hourly - каждый час;
* /etc/cron.daily - каждый день;
* /etc/cron.weekly - каждую неделю;
* /etc/cron.monthly - каждый месяц.
В этих папках должны находиться скрипты, которые нужно выполнять с указанным интервалом. Скрипты должны иметь права на выполнение и их имя не должно содержать точки. Это очень сильно облегчает работу с планировщиком для новых пользователей. Также в файле crontab прописан запуск команды anacron, которая работает так же как и cron, только предназначена для задач, которые нужно выполнять раз в длительный период, например, раз в день, неделю, месяц, год.
Она позволяет выполнять их даже если компьютер работает не всегда и время от времени выключается. Дата выполнения задания последний раз записывается в файл /var/spool/anacron, а затем, при следующем запуске anacron проверяет был ли запущен нужный процесс в нужное время, и если нет, то запускает его. Сам же сервис cron больше рассчитан на выполнение задач в течение дня или с точно расписанным временем и датой.
**НАСТРОЙКА CRON.**
Для настройки времени, даты и интервала когда нужно выполнять задание используется специальный синтаксис файла cron и специальная команда. Отредактируем файл планировщика задач /etc/crontab, введя туда необходимую задачу по синтаксису crontab:
* `sudo vim etc/crontab` и добавим строку со скриншота, таким образом, мы установим запуск команды uptime каждые две минуты.
![15sudovim.png](15sudovim.png)
**СИНТАКСИС CRONTAB.**
* Время задается особым синтаксисом, давайте рассмотрим синтаксис настройки одной задачи cron:
минута час день месяц день_недели /путь/к/исполняемому/файлу
Нужно сказать, что обязательно нужно писать полный путь к команде, потому что для команд, запускаемых от имени cron переменная среды PATH будет отличаться, и сервис просто не сможет найти вашу команду. Это вторая самая распространенная причина проблем с Cron. Дата и время указываются с помощью цифр или символа '*'. Этот символ означает, что нужно выполнять каждый раз, если в первом поле - то каждую минуту и так далее.
Вы можете захотеть не указывать отдельно время, а просто указать интервал, с которым нужно запускать скрипт, например, раз в 10 минут. Для этого используется разделитель косая черта - "/":
*/10 * * * * /usr/local/bin/serve
Также будем перенаправлять запись об отработке cron в текстовый файл /tmp/test_cron.txt, это следует устанавливать с той целью, чтобы не возникали warning'и.
Теперь в системном журнале проверим наличие записей о работе вызовов команды используя следующую команду с перенапрвлением данных в файл cron_data.txt.
* Найдём записи работы cron в системном журанле "syslog":
`sudo grep CRON /var/log/syslog`
![15syslog.png](15syslog.png)
* Выведем список текущих задач для CRON, прочитав файл /var/crontab:
![15listoftasks.png](15listoftasks.png)
* Удалим все задания из планировщика заданий отредактировав файл `sudo vim etc/crontab`
![15remove.png](15remove.png)
